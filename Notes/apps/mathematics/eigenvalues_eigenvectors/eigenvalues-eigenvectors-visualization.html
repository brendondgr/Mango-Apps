<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eigenvalues & Eigenvectors: Unit Circle to Ellipse</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700&family=DM+Sans:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: #FEFBF6;
            color: #333;
            overflow: hidden;
            height: 100vh;
            touch-action: manipulation;
        }

        .container {
            width: 100%;
            height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 700;
            color: #4C3BCF;
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            text-align: center;
            color: #666;
            font-weight: 500;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            border-radius: 12px;
            background: white;
            box-shadow: 0 8px 32px rgba(0,0,0,0.08);
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-width: 120px;
        }

        .control-label {
            font-size: 0.85rem;
            font-weight: 500;
            color: #555;
            text-align: center;
        }

        input[type="range"] {
            width: 100px;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4C3BCF;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(76,59,207,0.3);
        }

        .matrix-display {
            font-family: 'Space Grotesk', monospace;
            font-size: 0.9rem;
            font-weight: 500;
            color: #4C3BCF;
            background: #f8fafc;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            min-width: 200px;
            text-align: center;
        }

        .eigen-info {
            background: linear-gradient(135deg, #4C3BCF, #a855f7);
            color: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(76,59,207,0.2);
            text-align: center;
        }

        .eigen-item {
            margin: 10px 0;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .instructions {
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            border-radius: 12px;
            padding: 20px;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .control-group {
                flex-direction: row;
                justify-content: center;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>**Eigenvalues & Eigenvectors**</h1>
        <p class="subtitle">Watch a unit circle transform into an ellipse - the **major & minor axes** reveal the matrix's "DNA"</p>
        
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>

        <div class="eigen-info">
            <div class="eigen-item" id="eigen1">Œª‚ÇÅ = <span id="lambda1">1.00</span><br>v‚ÇÅ = <span id="vec1">[1, 0]</span></div>
            <div class="eigen-item" id="eigen2">Œª‚ÇÇ = <span id="lambda2">1.00</span><br>v‚ÇÇ = <span id="vec2">[0, 1]</span></div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label class="control-label">Matrix A‚ÇÅ‚ÇÅ</label>
                <input type="range" id="a11" min="-2" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label class="control-label">Matrix A‚ÇÅ‚ÇÇ</label>
                <input type="range" id="a12" min="-1" max="1.5" step="0.1" value="0.6">
            </div>
            <div class="control-group">
                <label class="control-label">Matrix A‚ÇÇ‚ÇÅ</label>
                <input type="range" id="a21" min="-1" max="1.5" step="0.1" value="0.8">
            </div>
            <div class="control-group">
                <label class="control-label">Matrix A‚ÇÇ‚ÇÇ</label>
                <input type="range" id="a22" min="-2" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <div class="matrix-display" id="matrixDisplay">
                    [ 1.0  0.6 ]<br>
                    [ 0.8  1.0 ]
                </div>
            </div>
        </div>

        <div class="instructions">
            <strong>üéØ How to explore:</strong><br>
            ‚Ä¢ Drag the **sliders** to change the **2x2 matrix**<br>
            ‚Ä¢ Watch the **unit circle** ‚Üí **ellipse** transformation<br>
            ‚Ä¢ **Purple & Teal lines** = **eigenvectors** (unchanging directions)<br>
            ‚Ä¢ **Lengths** = **eigenvalues** (scaling factors)<br>
            ‚Ä¢ **Grid** shows how all vectors transform
        </div>
    </div>

    <script>
        class EigenVisualization {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.initControls();
                this.animate();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
                this.scale = Math.min(this.centerX, this.centerY) * 0.85;
            }

            initControls() {
                const sliders = ['a11', 'a12', 'a21', 'a22'];
                sliders.forEach(id => {
                    document.getElementById(id).addEventListener('input', () => {
                        this.updateMatrix();
                        this.updateDisplay();
                    });
                });
            }

            updateMatrix() {
                this.A = [
                    [parseFloat(document.getElementById('a11').value), parseFloat(document.getElementById('a12').value)],
                    [parseFloat(document.getElementById('a21').value), parseFloat(document.getElementById('a22').value)]
                ];
                this.computeEigen();
            }

            computeEigen() {
                // Numerical eigenvalue decomposition for 2x2 matrix
                const a = this.A[0][0], b = this.A[0][1], c = this.A[1][0], d = this.A[1][1];
                const trace = a + d;
                const det = a*d - b*c;
                const disc = Math.sqrt((trace*trace - 4*det));
                
                this.eigenvalues = [
                    (trace + disc)/2,
                    (trace - disc)/2
                ];

                // Eigenvectors (normalized)
                this.eigenvectors = [];
                for (let i = 0; i < 2; i++) {
                    const lambda = this.eigenvalues[i];
                    const dx = a - lambda;
                    const dy = b;
                    const len = Math.sqrt(dx*dx + dy*dy) || 1;
                    this.eigenvectors[i] = [dx/len, dy/len];
                }

                this.updateEigenDisplay();
            }

            updateEigenDisplay() {
                document.getElementById('lambda1').textContent = this.eigenvalues[0].toFixed(2);
                document.getElementById('lambda2').textContent = this.eigenvalues[1].toFixed(2);
                
                document.getElementById('vec1').textContent = 
                    `[${this.eigenvectors[0][0].toFixed(2)}, ${this.eigenvectors[0][1].toFixed(2)}]`;
                document.getElementById('vec2').textContent = 
                    `[${this.eigenvectors[1][0].toFixed(2)}, ${this.eigenvectors[1][1].toFixed(2)}]`;
            }

            updateDisplay() {
                const a11 = document.getElementById('a11').value;
                const a12 = document.getElementById('a12').value;
                const a21 = document.getElementById('a21').value;
                const a22 = document.getElementById('a22').value;
                document.getElementById('matrixDisplay').innerHTML = 
                    `[ ${a11.padStart(4)}  ${a12.padStart(4)} ]<br>[ ${a21.padStart(4)}  ${a22.padStart(4)} ]`;
            }

            applyMatrix(x, y) {
                const x1 = this.A[0][0] * x + this.A[0][1] * y;
                const y1 = this.A[1][0] * x + this.A[1][1] * y;
                return [x1, y1];
            }

            draw() {
                this.ctx.fillStyle = '#FEFBF6';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.save();
                this.ctx.translate(this.centerX, this.centerY);
                this.ctx.scale(this.scale, this.scale);
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                // Grid
                this.drawGrid();

                // Eigenvectors (thick lines)
                this.drawEigenvectors();

                // Unit circle (original)
                this.drawUnitCircle(false);

                // Transformed ellipse
                this.drawUnitCircle(true);

                // Eigenvector arrows with labels
                this.drawEigenArrows();

                this.ctx.restore();
            }

            drawGrid() {
                this.ctx.strokeStyle = '#f1f5f9';
                this.ctx.lineWidth = 0.015;
                this.ctx.beginPath();
                for (let i = -1.2; i <= 1.2; i += 0.2) {
                    this.ctx.moveTo(-1.2, i);
                    this.ctx.lineTo(1.2, i);
                    this.ctx.moveTo(i, -1.2);
                    this.ctx.lineTo(i, 1.2);
                }
                this.ctx.stroke();

                // Axes
                this.ctx.strokeStyle = '#e2e8f0';
                this.ctx.lineWidth = 0.025;
                this.ctx.beginPath();
                this.ctx.moveTo(-1.2, 0);
                this.ctx.lineTo(1.2, 0);
                this.ctx.moveTo(0, -1.2);
                this.ctx.lineTo(0, 1.2);
                this.ctx.stroke();
            }

            drawEigenvectors() {
                const colors = ['#a855f7', '#14b8a6']; // Purple, Teal
                this.ctx.lineWidth = 0.035;
                
                for (let i = 0; i < 2; i++) {
                    this.ctx.strokeStyle = colors[i];
                    this.ctx.lineDashOffset = 0;
                    this.ctx.setLineDash([0.08, 0.08]);
                    this.ctx.beginPath();
                    const len = 1.1;
                    const x1 = this.eigenvectors[i][0] * len;
                    const y1 = this.eigenvectors[i][1] * len;
                    const x2 = -x1;
                    const y2 = -y1;
                    this.ctx.moveTo(x2, y2);
                    this.ctx.lineTo(x1, y1);
                    this.ctx.stroke();
                }
                this.ctx.setLineDash([]);
            }

            drawUnitCircle(transformed) {
                const segments = 64;
                this.ctx.beginPath();
                
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const x = Math.cos(angle);
                    const y = Math.sin(angle);
                    
                    if (transformed) {
                        const [tx, ty] = this.applyMatrix(x, y);
                        if (i === 0) this.ctx.moveTo(tx, ty);
                        else this.ctx.lineTo(tx, ty);
                    } else {
                        if (i === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.closePath();

                if (transformed) {
                    this.ctx.strokeStyle = '#3b82f6';
                    this.ctx.lineWidth = 0.04;
                    this.ctx.globalAlpha = 0.9;
                } else {
                    this.ctx.strokeStyle = '#10b981';
                    this.ctx.lineWidth = 0.025;
                    this.ctx.globalAlpha = 0.7;
                }
                this.ctx.stroke();
                this.ctx.globalAlpha = 1;
            }

            drawEigenArrows() {
                const colors = ['#a855f7', '#14b8a6'];
                const labels = ['Œª‚ÇÅ', 'Œª‚ÇÇ'];
                
                for (let i = 0; i < 2; i++) {
                    this.ctx.save();
                    this.ctx.translate(0, 0);
                    this.ctx.strokeStyle = colors[i];
                    this.ctx.fillStyle = colors[i];
                    this.ctx.lineWidth = 0.045;

                    // Arrow
                    const len = Math.abs(this.eigenvalues[i]) * 0.9;
                    const x = this.eigenvectors[i][0] * len;
                    const y = this.eigenvectors[i][1] * len;
                    
                    this.ctx.lineTo(x, y);
                    this.ctx.lineTo(x * 0.85, y * 0.85);
                    this.ctx.stroke();

                    // Arrow head
                    const angle = Math.atan2(y, x);
                    const headLen = 0.08;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, y);
                    this.ctx.lineTo(x - headLen * Math.cos(angle - 0.4), y - headLen * Math.sin(angle - 0.4));
                    this.ctx.lineTo(x - headLen * Math.cos(angle + 0.4), y - headLen * Math.sin(angle + 0.4));
                    this.ctx.closePath();
                    this.ctx.fill();

                    // Label
                    this.ctx.font = 'bold 0.12px DM Sans, sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(labels[i], x * 0.5, y * 0.5);

                    this.ctx.restore();
                }
            }

            animate() {
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize
        const viz = new EigenVisualization();
        viz.updateMatrix();
        viz.updateDisplay();
    </script>
</body>
</html>