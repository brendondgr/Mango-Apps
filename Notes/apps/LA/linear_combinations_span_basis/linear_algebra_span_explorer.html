<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linear Algebra: Spans & Bases</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&family=Space+Grotesk:wght@300..700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #FEFBF6;
            --primary: #4C3BCF;
            --accent: #FF6B6B;
            --blue: #3b82f6;
            --purple: #a855f7;
            --teal: #14b8a6;
            --orange: #f97316;
            --green: #10b981;
            --text: #2D3436;
            --card-bg: #FFFFFF;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'DM Sans', sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
            padding-bottom: 2rem;
        }

        h1, h2, h3 {
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 700;
        }

        header {
            padding: 2rem 1rem;
            text-align: center;
            background: white;
            box-shadow: 0 4px 20px rgba(76, 59, 207, 0.05);
            margin-bottom: 2rem;
        }

        header h1 {
            color: var(--primary);
            font-size: 2.2rem;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 1rem;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 2rem;
        }

        @media (max-width: 850px) {
            .container {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 30px rgba(0,0,0,0.04);
            border: 1px solid rgba(0,0,0,0.05);
            margin-bottom: 1.5rem;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            background: #fff;
            border-radius: 12px;
            cursor: move;
            touch-action: none;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 1.2rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .label-v1 { color: var(--blue); }
        .label-v2 { color: var(--purple); }
        .label-res { color: var(--accent); }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #eee;
            border-radius: 5px;
            appearance: none;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.2);
        }

        .toggle-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.8rem 1rem;
            border-radius: 8px;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .toggle-btn:hover {
            filter: brightness(1.1);
            transform: translateY(-2px);
        }

        .toggle-btn.secondary {
            background: #f0f0f0;
            color: var(--text);
        }

        .toggle-btn.active {
            background: var(--green);
        }

        .math-display {
            font-family: 'Space Grotesk', sans-serif;
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            font-size: 1.1rem;
            border-left: 4px solid var(--primary);
        }

        .info-panel h3 {
            margin-bottom: 0.5rem;
            color: var(--primary);
        }

        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            font-size: 0.85rem;
            margin-top: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 5px;
        }

        .badge-span { background: rgba(20, 184, 166, 0.2); color: var(--teal); }

        .hint {
            font-size: 0.8rem;
            color: #666;
            font-style: italic;
            margin-top: 0.5rem;
            text-align: center;
        }
    </style>
</head>
<body>

<header>
    <h1>Linear Algebra Explorer</h1>
    <p>Visualizing Linear Combinations, Spans, and Bases</p>
</header>

<div class="container">
    <div class="visualization-area">
        <div class="card canvas-container" id="container3d">
            <canvas id="vizCanvas"></canvas>
            <div style="position: absolute; bottom: 10px; right: 10px; pointer-events: none;">
                <p class="hint">Drag to Rotate • Scroll to Zoom</p>
            </div>
        </div>
        
        <div class="card info-panel">
            <h3>The Concept</h3>
            <p>Every vector in the <strong>Span</strong> of vectors <b>v₁</b> and <b>v₂</b> can be written as a linear combination: 
               <span style="color:var(--accent); font-weight:bold;">w = c₁v₁ + c₂v₂</span>.
            </p>
            <p id="independence-status" style="margin-top: 0.5rem; font-weight: bold;"></p>
        </div>
    </div>

    <div class="controls">
        <div class="card">
            <div class="math-display" id="equation">
                w = 1.0v₁ + 1.0v₂
            </div>
            
            <div class="control-group" style="margin-top: 1.5rem;">
                <div class="control-header">
                    <span class="label-v1">Scalar c₁: <span id="c1-val">1.0</span></span>
                </div>
                <input type="range" id="c1-slider" min="-2" max="2" step="0.1" value="1">
            </div>

            <div class="control-group">
                <div class="control-header">
                    <span class="label-v2">Scalar c₂: <span id="c2-val">1.0</span></span>
                </div>
                <input type="range" id="c2-slider" min="-2" max="2" step="0.1" value="1">
            </div>

            <div style="margin-top: 1rem; display: flex; flex-direction: column; gap: 0.8rem;">
                <button class="toggle-btn" id="toggleSpan">
                    Show Plane (Span)
                </button>
                <button class="toggle-btn secondary" id="resetCamera">
                    Reset View
                </button>
            </div>
        </div>

        <div class="card">
            <h3>Modify Vectors</h3>
            <p style="font-size: 0.85rem; color: #666; margin-bottom: 1rem;">Change the direction of the base vectors:</p>
            
            <div class="control-group">
                <div class="control-header label-v1">Vector v₁ Direction</div>
                <input type="range" id="v1-rot" min="0" max="6.28" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <div class="control-header label-v2">Vector v₂ Direction</div>
                <input type="range" id="v2-rot" min="0" max="6.28" step="0.1" value="2.1">
            </div>

            <div class="legend">
                <div class="legend-item"><div class="dot" style="background:var(--blue)"></div> v₁</div>
                <div class="legend-item"><div class="dot" style="background:var(--purple)"></div> v₂</div>
                <div class="legend-item"><div class="dot" style="background:var(--accent)"></div> Resultant w</div>
                <div class="legend-item"><div class="dot" style="background:var(--teal); opacity: 0.4;"></div> Span</div>
            </div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('vizCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('container3d');

    // UI Elements
    const c1Slider = document.getElementById('c1-slider');
    const c2Slider = document.getElementById('c2-slider');
    const v1RotSlider = document.getElementById('v1-rot');
    const v2RotSlider = document.getElementById('v2-rot');
    const c1ValDisp = document.getElementById('c1-val');
    const c2ValDisp = document.getElementById('c2-val');
    const equationDisp = document.getElementById('equation');
    const spanBtn = document.getElementById('toggleSpan');
    const resetBtn = document.getElementById('resetCamera');
    const statusText = document.getElementById('independence-status');

    // State
    let width, height;
    let showSpan = false;
    let cameraAngleX = -0.5;
    let cameraAngleY = 0.6;
    let zoom = 50;

    let v1 = { x: 2, y: 0, z: 1 };
    let v2 = { x: 0, y: 2, z: 1 };
    let c1 = 1.0;
    let c2 = 1.0;

    // 3D Projection Engine
    function project(x, y, z) {
        // Rotate around Y-axis
        let x1 = x * Math.cos(cameraAngleY) + z * Math.sin(cameraAngleY);
        let z1 = -x * Math.sin(cameraAngleY) + z * Math.cos(cameraAngleY);
        
        // Rotate around X-axis
        let y2 = y * Math.cos(cameraAngleX) - z1 * Math.sin(cameraAngleX);
        let z2 = y * Math.sin(cameraAngleX) + z1 * Math.cos(cameraAngleX);
        
        // Simple perspective projection
        const focalLength = 400;
        const scale = focalLength / (focalLength + z2);
        
        return {
            x: x1 * scale * zoom + width / 2,
            y: -y2 * scale * zoom + height / 2,
            z: z2,
            scale: scale
        };
    }

    function resize() {
        width = container.clientWidth;
        height = container.clientHeight;
        canvas.width = width * window.devicePixelRatio;
        canvas.height = height * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    window.addEventListener('resize', resize);
    resize();

    // Interaction
    let isDragging = false;
    let lastMouseX, lastMouseY;

    container.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
    });

    window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        cameraAngleY += dx * 0.01;
        cameraAngleX += dy * 0.01;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        draw();
    });

    window.addEventListener('mouseup', () => isDragging = false);

    // Touch interaction
    container.addEventListener('touchstart', (e) => {
        isDragging = true;
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
        e.preventDefault();
    }, {passive: false});

    container.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        const dx = e.touches[0].clientX - lastMouseX;
        const dy = e.touches[0].clientY - lastMouseY;
        cameraAngleY += dx * 0.01;
        cameraAngleX += dy * 0.01;
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
        draw();
        e.preventDefault();
    }, {passive: false});

    container.addEventListener('touchend', () => isDragging = false);

    container.addEventListener('wheel', (e) => {
        zoom -= e.deltaY * 0.05;
        zoom = Math.max(20, Math.min(150, zoom));
        draw();
        e.preventDefault();
    }, {passive: false});

    // Control listeners
    c1Slider.addEventListener('input', (e) => {
        c1 = parseFloat(e.target.value);
        c1ValDisp.innerText = c1.toFixed(1);
        updateEquation();
        draw();
    });

    c2Slider.addEventListener('input', (e) => {
        c2 = parseFloat(e.target.value);
        c2ValDisp.innerText = c2.toFixed(1);
        updateEquation();
        draw();
    });

    v1RotSlider.addEventListener('input', (e) => {
        const ang = parseFloat(e.target.value);
        v1.x = Math.cos(ang) * 3;
        v1.z = Math.sin(ang) * 3;
        v1.y = Math.sin(ang * 0.5) * 2;
        checkIndependence();
        draw();
    });

    v2RotSlider.addEventListener('input', (e) => {
        const ang = parseFloat(e.target.value);
        v2.x = Math.cos(ang) * 3;
        v2.z = Math.sin(ang) * 3;
        v2.y = Math.cos(ang * 0.5) * 2;
        checkIndependence();
        draw();
    });

    spanBtn.addEventListener('click', () => {
        showSpan = !showSpan;
        spanBtn.classList.toggle('active');
        spanBtn.innerText = showSpan ? "Hide Plane (Span)" : "Show Plane (Span)";
        draw();
    });

    resetBtn.addEventListener('click', () => {
        cameraAngleX = -0.5;
        cameraAngleY = 0.6;
        zoom = 50;
        draw();
    });

    function updateEquation() {
        equationDisp.innerHTML = `w = <span style="color:var(--blue)">${c1.toFixed(1)}v₁</span> + <span style="color:var(--purple)">${c2.toFixed(1)}v₂</span>`;
    }

    function checkIndependence() {
        // Cross product magnitude to check if collinear
        const cp = {
            x: v1.y * v2.z - v1.z * v2.y,
            y: v1.z * v2.x - v1.x * v2.z,
            z: v1.x * v2.y - v1.y * v2.x
        };
        const mag = Math.sqrt(cp.x**2 + cp.y**2 + cp.z**2);
        if (mag < 0.1) {
            statusText.innerHTML = "⚠️ Vectors are <span style='color:var(--accent)'>Linearly Dependent</span>. Their span is only a 1D line.";
        } else {
            statusText.innerHTML = "✅ Vectors are <span style='color:var(--green)'>Linearly Independent</span>. They form a basis for a 2D plane.";
        }
    }

    // Drawing helpers
    function drawLine(p1, p2, color, width = 2, dash = []) {
        ctx.beginPath();
        ctx.setLineDash(dash);
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function drawArrow(p1, p2, color, width = 3) {
        drawLine(p1, p2, color, width);
        
        // Simple arrowhead
        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
        ctx.beginPath();
        ctx.moveTo(p2.x, p2.y);
        ctx.lineTo(p2.x - 10 * Math.cos(angle - Math.PI / 6), p2.y - 10 * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(p2.x - 10 * Math.cos(angle + Math.PI / 6), p2.y - 10 * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
    }

    function drawGrid() {
        const size = 5;
        const color = "#ddd";
        for (let i = -size; i <= size; i++) {
            drawLine(project(i, 0, -size), project(i, 0, size), color, 1);
            drawLine(project(-size, 0, i), project(size, 0, i), color, 1);
        }
        
        // Axes
        drawArrow(project(0, 0, 0), project(size + 1, 0, 0), "#aaa", 1); // X
        drawArrow(project(0, 0, 0), project(0, size + 1, 0), "#aaa", 1); // Y
        drawArrow(project(0, 0, 0), project(0, 0, size + 1), "#aaa", 1); // Z
    }

    function drawSpanPlane() {
        if (!showSpan) return;
        
        const size = 10;
        const points = [
            { s: -size, t: -size },
            { s: size, t: -size },
            { s: size, t: size },
            { s: -size, t: size }
        ];
        
        const projPoints = points.map(p => {
            const x = p.s * v1.x + p.t * v2.x;
            const y = p.s * v1.y + p.t * v2.y;
            const z = p.s * v1.z + p.t * v2.z;
            return project(x, y, z);
        });

        ctx.beginPath();
        ctx.moveTo(projPoints[0].x, projPoints[0].y);
        for (let i = 1; i < projPoints.length; i++) {
            ctx.lineTo(projPoints[i].x, projPoints[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = "rgba(20, 184, 166, 0.15)";
        ctx.fill();
        ctx.strokeStyle = "rgba(20, 184, 166, 0.3)";
        ctx.lineWidth = 1;
        ctx.stroke();

        // Draw internal grid for the plane
        for (let i = -size; i <= size; i++) {
            const startA = project(i * v1.x - size * v2.x, i * v1.y - size * v2.y, i * v1.z - size * v2.z);
            const endA = project(i * v1.x + size * v2.x, i * v1.y + size * v2.y, i * v1.z + size * v2.z);
            drawLine(startA, endA, "rgba(20, 184, 166, 0.1)", 1);
            
            const startB = project(-size * v1.x + i * v2.x, -size * v1.y + i * v2.y, -size * v1.z + i * v2.z);
            const endB = project(size * v1.x + i * v2.x, size * v1.y + i * v2.y, size * v1.z + i * v2.z);
            drawLine(startB, endB, "rgba(20, 184, 166, 0.1)", 1);
        }
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);
        
        drawGrid();
        
        if (showSpan) drawSpanPlane();

        const origin = project(0, 0, 0);
        const pv1 = project(v1.x, v1.y, v1.z);
        const pv2 = project(v2.x, v2.y, v2.z);
        
        // Draw components for combination
        const cv1 = { x: v1.x * c1, y: v1.y * c1, z: v1.z * c1 };
        const cv2 = { x: v2.x * c2, y: v2.y * c2, z: v2.z * c2 };
        const res = { x: cv1.x + cv2.x, y: cv1.y + cv2.y, z: cv1.z + cv2.z };
        
        const pcv1 = project(cv1.x, cv1.y, cv1.z);
        const pres = project(res.x, res.y, res.z);

        // Visualizing the addition (Parallelogram rule)
        drawLine(pcv1, pres, varColor('--purple'), 1, [5, 5]);
        const pcv2_offset = project(cv2.x, cv2.y, cv2.z);
        drawLine(pcv2_offset, pres, varColor('--blue'), 1, [5, 5]);

        // Draw main vectors
        drawArrow(origin, pv1, varColor('--blue'), 3);
        drawArrow(origin, pv2, varColor('--purple'), 3);
        
        // Resultant
        drawArrow(origin, pres, varColor('--accent'), 4);

        // Labels
        ctx.font = "bold 14px Space Grotesk";
        ctx.fillStyle = varColor('--blue');
        ctx.fillText("v₁", pv1.x + 10, pv1.y);
        ctx.fillStyle = varColor('--purple');
        ctx.fillText("v₂", pv2.x + 10, pv2.y);
        ctx.fillStyle = varColor('--accent');
        ctx.fillText("w", pres.x + 10, pres.y);
    }

    function varColor(name) {
        const colors = {
            '--primary': '#4C3BCF',
            '--blue': '#3b82f6',
            '--purple': '#a855f7',
            '--teal': '#14b8a6',
            '--accent': '#FF6B6B',
            '--green': '#10b981'
        };
        return colors[name] || '#000000';
    }

    // Initialize
    updateEquation();
    checkIndependence();
    // Default angles for vectors
    v1.x = Math.cos(0.5) * 3; v1.z = Math.sin(0.5) * 3; v1.y = Math.sin(0.25) * 2;
    v2.x = Math.cos(2.1) * 3; v2.z = Math.sin(2.1) * 3; v2.y = Math.cos(1.05) * 2;
    draw();

</script>

</body>
</html>