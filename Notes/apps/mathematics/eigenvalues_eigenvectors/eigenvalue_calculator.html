<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eigenvalue & Eigenvector Calculator</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700&family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #FEFBF6;
            font-family: 'DM Sans', sans-serif;
            color: #333;
            padding: 20px;
        }
        .container { max-width: 800px; margin: 0 auto; }
        
        h1 { font-family: 'Space Grotesk', sans-serif; color: #4C3BCF; margin-bottom: 20px; text-align: center; }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            margin-bottom: 20px;
            text-align: center;
        }

        .matrix-grid {
            display: inline-grid;
            gap: 10px;
            margin: 20px 0;
            padding: 15px;
            background: #F8F5FC;
            border-radius: 10px; /* Rounded brackets simulation */
            border-left: 2px solid #4C3BCF;
            border-right: 2px solid #4C3BCF;
        }

        .matrix-grid input {
            width: 60px;
            padding: 8px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Space Grotesk', monospace;
            font-size: 1.1em;
        }

        .btn-group { margin-bottom: 15px; display: flex; justify-content: center; gap: 10px; }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.2s;
        }
        
        .btn-mode { background: #e5e7eb; color: #555; }
        .btn-mode.active { background: #4C3BCF; color: white; }
        
        .btn-calc { background: #10b981; color: white; font-size: 1.1em; padding: 12px 30px; }
        .btn-calc:hover { background: #059669; transform: translateY(-2px); }

        .steps-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .step-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            border-left: 5px solid #4C3BCF;
            opacity: 0;
            transform: translateY(20px);
            animation: slideIn 0.5s forwards;
        }

        .step-title {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.2em;
            color: #4C3BCF;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .step-number {
            background: #4C3BCF;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
        }

        .math-block {
            font-family: 'Space Grotesk', monospace;
            background: #F8F5FC;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            margin-top: 10px;
            font-size: 1.1em;
            color: #333;
            text-align: center;
        }

        @keyframes slideIn {
            to { opacity: 1; transform: translateY(0); }
        }

        /* MathJax adjustments */
        mjx-container { font-size: 110% !important; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Eigenvalue Calculator</h1>

        <div class="controls">
            <div class="btn-group">
                <button class="btn-mode active" onclick="setSize(2)">2x2 Matrix</button>
                <button class="btn-mode" onclick="setSize(3)">3x3 Matrix</button>
            </div>

            <div id="matrixInput" class="matrix-grid" style="grid-template-columns: repeat(2, 1fr);">
                <!-- Generated by JS -->
            </div>

            <br>
            <button class="btn-calc" onclick="calculate()">Calculate Step-by-Step</button>
        </div>

        <div id="output" class="steps-container"></div>
    </div>

    <script>
        let size = 2;

        // Initialize MathJax
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
        };

        function setSize(s) {
            size = s;
            document.querySelectorAll('.btn-mode').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            renderInputs();
        }

        function renderInputs() {
            const container = document.getElementById('matrixInput');
            container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            container.innerHTML = '';
            
            // Defaults with nice integer eigenvalues for demonstration
            // 2x2: (4-L)(3-L)-2 = 12-7L+L^2-2 = L^2-7L+10 = (L-5)(L-2) -> 5, 2
            const def2 = [4, 1, 2, 3]; 
            // 3x3: Block diagonal [2,0,0; 0,3,4; 0,4,9]
            const def3 = [2, 0, 0, 0, 3, 4, 0, 4, 9]; 
            
            const defs = size === 2 ? def2 : def3;

            for(let i=0; i<size*size; i++) {
                const inp = document.createElement('input');
                inp.type = 'number';
                inp.value = defs[i];
                inp.id = `m${i}`;
                container.appendChild(inp);
            }
            document.getElementById('output').innerHTML = '';
        }

        function getMatrix() {
            let m = [];
            for(let r=0; r<size; r++) {
                let row = [];
                for(let c=0; c<size; c++) {
                    const val = parseFloat(document.getElementById(`m${r*size + c}`).value);
                    m.push(isNaN(val) ? 0 : val);
                }
                m.push(row);
            }
            return m;
        }

        // --- Math Helpers ---

        function toTex(n) {
            if (Math.abs(n) < 1e-10) return "0";
            if (math.abs(Math.round(n) - n) < 0.001) return Math.round(n).toString();
            return n.toFixed(3);
        }

        function matrixTex(M) {
            if (!M || M.length === 0) return "";
            return "\\begin{bmatrix}" + 
                M.map(row => row.map(v => toTex(v)).join(" & ")).join(" \\\\ ") + 
                "\\end{bmatrix}";
        }

        function matrixPolyTex(M) {
            // Render A - Î»I
            return "\\begin{bmatrix}" + 
                M.map((row, r) => row.map((v, c) => {
                    let val = toTex(v);
                    if (r === c) {
                        return `(${val} - \\lambda)`;
                    }
                    return val;
                }).join(" & ")).join(" \\\\ ") + 
                "\\end{bmatrix}";
        }

        async function calculate() {
            const container = document.getElementById('output');
            container.innerHTML = '';
            
            const M = getMatrix(); 
            const matrixObj = math.matrix(M);

            // --- Step 1: Characteristic Equation ---
            let step1Html = `
                <div class="step-title"><span class="step-number">1</span>Characteristic Equation</div>
                <p>To find the eigenvalues, we solve the characteristic equation:</p>
                <div class="math-block">
                    $$ \\det(A - \\lambda I) = 0 $$
                </div>
                <p>Substituting our matrix $A$:</p>
                <div class="math-block">
                    $$ \\det ${matrixPolyTex(M)} = 0 $$
                </div>
            `;

            let simplifiedPoly = "";
            
            if (size === 2) {
                const a = M[0][0], b = M[0][1], c = M[1][0], d = M[1][1];
                const trace = a + d;
                const det = a*d - b*c;
                const polyString = `(${toTex(a)} - \\lambda)(${toTex(d)} - \\lambda) - (${toTex(b)})(${toTex(c)})`;
                simplifiedPoly = `\\lambda^2 - ${toTex(trace)}\\lambda + ${toTex(det)}`;
                
                step1Html += `
                    <p>For a 2x2 matrix, determinant is $ad - bc$:</p>
                    <div class="math-block">
                        $$ ${polyString} = 0 $$
                    </div>
                    <p>Expanding and simplifying:</p>
                    <div class="math-block">
                        $$ ${simplifiedPoly} = 0 $$
                    </div>
                `;
            } else {
                // 3x3 expansion logic
                const [r0, r1, r2] = M;
                step1Html += `
                    <p>Expanding the determinant along the first row:</p>
                    <div class="math-block" style="font-size: 0.9em">
                        $$ (${toTex(r0[0])}-\\lambda) \\left| \\begin{matrix} ${toTex(r1[1])}-\\lambda & ${toTex(r1[2])} \\\\ ${toTex(r2[1])} & ${toTex(r2[2])}-\\lambda \\end{matrix} \\right| 
                           - (${toTex(r0[1])}) \\left| \\begin{matrix} ${toTex(r1[0])} & ${toTex(r1[2])} \\\\ ${toTex(r2[0])} & ${toTex(r2[2])}-\\lambda \\end{matrix} \\right| 
                           + (${toTex(r0[2])}) \\left| \\begin{matrix} ${toTex(r1[0])} & ${toTex(r1[1])} \\\\ ${toTex(r2[0])} & ${toTex(r2[1])} \\end{matrix} \\right|
                           = 0 $$
                    </div>
                `;
                
                const trace = math.trace(matrixObj);
                const det = math.det(matrixObj);
                const m11 = M[1][1]*M[2][2] - M[1][2]*M[2][1];
                const m22 = M[0][0]*M[2][2] - M[0][2]*M[2][0];
                const m33 = M[0][0]*M[1][1] - M[0][1]*M[1][0];
                const sumMinors = m11 + m22 + m33;
                
                const sTrace = trace < 0 ? `- ${toTex(Math.abs(trace))}` : `+ ${toTex(trace)}`;
                // Note: The formula is -lambda^3 + trace*lambda^2 - ...
                // But typically we solve lambda^3 - trace*lambda^2 + ... = 0 (multiplying by -1)
                // Let's stick to standard det expansion: det(A-lI) usually starts with -l^3
                
                simplifiedPoly = `-\\lambda^3 + ${toTex(trace)}\\lambda^2 - ${toTex(sumMinors)}\\lambda + ${toTex(det)}`;
                
                step1Html += `
                    <p>Simplifying gives the characteristic polynomial:</p>
                    <div class="math-block">
                        $$ ${simplifiedPoly} = 0 $$
                    </div>
                `;
            }

            addStep(container, step1Html, 0);

            // --- Step 2: Eigenvalues ---
            const eigs = math.eigs(matrixObj);
            const values = eigs.values;
            
            // Nice text formatting
            const niceValues = values.map(v => {
                if (math.isComplex(v)) {
                    if (Math.abs(v.im) < 1e-10) return toTex(v.re);
                    return `${toTex(v.re)} ${v.im >= 0 ? '+' : '-'} ${toTex(Math.abs(v.im))}i`;
                }
                return toTex(v);
            });

            addStep(container, `
                <div class="step-title"><span class="step-number">2</span>Eigenvalues</div>
                <p>Solving the polynomial roots gives the eigenvalues:</p>
                <div class="math-block">
                     $$ \\lambda \\in \\{ ${niceValues.join(', ')} \\} $$
                </div>
            `, 100);

            // --- Step 3: Eigenvectors ---
            let eigStepHtml = `<div class="step-title"><span class="step-number">3</span>Eigenvectors</div>`;
            
            // Deduplicate for display
            const uniqueLambdas = [];
            values.forEach(v => {
                let valToCheck = typeof v === 'number' ? v : v.re; // simplified check
                // This complex check is simple; robust check would require full complex check
                // For this demo, let's rely on string repr for uniqueness
                let str = math.isComplex(v) && Math.abs(v.im) > 1e-10 ? `${toTex(v.re)}${v.im>=0?'+':''}${toTex(v.im)}i` : toTex(v);
                
                if(!uniqueLambdas.find(u => u.str === str)) {
                    uniqueLambdas.push({ val: v, str: str });
                }
            });

            for (let i = 0; i < uniqueLambdas.length; i++) {
                const lambda = uniqueLambdas[i];
                eigStepHtml += `<h3>For $\\lambda = ${lambda.str}$:</h3>`;
                eigStepHtml += `<p>Solve $(A - ${lambda.str}I)\\mathbf{v} = \\mathbf{0}$. We reduce the augmented matrix:</p>`;

                const isComplex = typeof lambda.val === 'object' && Math.abs(lambda.val.im) > 1e-10;
                
                if (isComplex) {
                    eigStepHtml += `<p><em>(Showing simplified result for complex eigenvalue)</em></p>`;
                    // Find vector
                    const idx = values.findIndex(v => {
                        if(typeof v === 'number') return false; 
                        return Math.abs(v.re - lambda.val.re) < 0.001; 
                    });
                    
                    let col = [];
                    for(let r=0; r<size; r++) {
                        let c = eigs.vectors.get([r, idx]);
                        col.push(typeof c === 'object' ? `${toTex(c.re)}${c.im>=0?'+':''}${toTex(c.im)}i` : toTex(c));
                    }
                    
                    eigStepHtml += `
                    <div class="math-block">
                        $$ \\mathbf{v} \\approx \\begin{bmatrix} ${col.join(" \\\\ ")} \\end{bmatrix} $$
                    </div><hr>`;
                    continue;
                }

                // Real eigenvalue
                const lambdaVal = typeof lambda.val === 'number' ? lambda.val : lambda.val.re;
                let augM = M.map(row => row.map(v => v));
                for(let k=0; k<size; k++) augM[k][k] -= lambdaVal;
                
                eigStepHtml += `
                <div class="math-block">
                    $$ \\left[ \\begin{array}{${'c'.repeat(size)}|c} 
                    ${augM.map(row => row.map(v=>toTex(v)).join(' & ')).join(' \\\\ ')} & 0
                    \\end{array} \\right] $$
                </div>
                `;
                
                // Perform RREF
                const rrefRes = computedRref(augM);
                const finalM = rrefRes.M;
                
                eigStepHtml += `<p>Row reducing to RREF:</p>
                <div class="math-block">
                    $$ \\sim \\left[ \\begin{array}{${'c'.repeat(size)}|c} 
                    ${finalM.map(row => row.map(v=>toTex(v)).join(' & ')).join(' \\\\ ')} & 0
                    \\end{array} \\right] $$
                </div>`;

                // Calculate vector from RREF (Visual only fallback to math.js vector for reliability)
                // Doing the "free variable" logic fully robustly in JS for all edge cases is heavy.
                // We will display the math.js vector as the "Solution".
                
                // Find matching vector from library result
                let matchIdx = values.findIndex(v => Math.abs((typeof v==='number'?v:v.re) - lambdaVal) < 0.001);
                let vec = [];
                for(let r=0; r<size; r++) vec.push(eigs.vectors.get([r, matchIdx]));

                // Normalize for display (integers preference)
                let maxVal = 0;
                vec.forEach(x => { if(Math.abs(x) > maxVal) maxVal = Math.abs(x); });
                if (maxVal > 0) {
                     // Normalize so largest is 1, then check if others are rational
                     // Or just divide by smallest non-zero
                     let minVal = Infinity;
                     vec.forEach(x => { if(Math.abs(x)>1e-6 && Math.abs(x)<minVal) minVal=Math.abs(x); });
                     let niceVec = vec.map(x => x/minVal);
                     // Check if roundable
                     if(niceVec.every(x => Math.abs(x - Math.round(x)) < 0.01)) {
                         vec = niceVec.map(x => Math.round(x));
                     }
                }
                
                eigStepHtml += `<p>The subspace is spanned by:</p>
                    <div class="math-block">
                        $$ \\mathbf{v} = \\begin{bmatrix} ${vec.map(c => toTex(c)).join(" \\\\ ")} \\end{bmatrix} $$
                    </div><hr>
                `;
            }
            
            addStep(container, eigStepHtml, 200);

            // Trigger MathJax
            if (window.MathJax) {
                 // MathJax 3 async typeset
                 MathJax.typesetPromise([container]).catch((err) => console.log(err));
            }
        }

        function addStep(container, html, delay) {
            const div = document.createElement('div');
            div.className = 'step-card';
            div.style.animationDelay = delay + 'ms';
            div.innerHTML = html;
            container.appendChild(div);
        }

        function computedRref(A) {
            let M = A.map(row => [...row]);
            let pivotRow = 0;
            const rows = M.length;
            const cols = M[0].length;

            for (let c = 0; c < cols && pivotRow < rows; c++) {
                let i = pivotRow;
                while (i < rows && Math.abs(M[i][c]) < 1e-6) i++;
                if (i === rows) continue; 

                [M[pivotRow], M[i]] = [M[i], M[pivotRow]];

                let pivotVal = M[pivotRow][c];
                for (let j = c; j < cols; j++) M[pivotRow][j] /= pivotVal;

                for (let r = 0; r < rows; r++) {
                    if (r !== pivotRow) {
                        let factor = M[r][c];
                        for (let j = c; j < cols; j++) M[r][j] -= factor * M[pivotRow][j];
                    }
                }
                pivotRow++;
            }
            return { M: M };
        }
        
        renderInputs();
    </script>
</body>
</html>
